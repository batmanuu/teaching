# -*- coding: utf-8 -*-
"""TIMESHARINGSO.ipynb

Automatically generated by Colaboratory.

# Importação das bibliotecas necessárias
import random  # Importa a biblioteca random para geração de números aleatórios
import simpy   # Importa a biblioteca SimPy para simulação de eventos discretos

# Definição da função de processo para simulação do time sharing
def processo(name, env, memoria, cpu, chegada, instrucoes, ram, quantum):
    yield env.timeout(chegada)  # Aguarda o tempo de chegada do processo no ambiente de simulação

    tempo_chegada = env.now  # Registra o tempo de chegada do processo

    # Exibe informações sobre a chegada do processo e a necessidade de RAM
    print('%s \nProcesso na fila [NOVO - Chegada] -> %d - Requer RAM: %d, Disponível: %d' % (name, env.now, ram, memoria.level))

    yield memoria.get(ram)  # Tenta adquirir a quantidade de RAM necessária para o processo

    # Enquanto houver instruções a serem executadas
    while instrucoes > 0:
        # Exibe informações sobre o estado do processo
        print('%s \nProcesso na fila PRONTO -> %d - Instruções restantes: %d' % (name, env.now, instrucoes))

        # Solicita acesso à CPU para execução das instruções
        with cpu.request() as req:
            yield req  # Espera até que a CPU esteja disponível para o processo

            # Executa as instruções de acordo com o quantum ou as instruções restantes, o que for menor
            for _ in range(min(quantum, instrucoes)):
                if instrucoes <= 0:  # Verifica se as instruções acabaram
                    break
                instrucoes -= 1  # Reduz o número de instruções restantes
                yield env.timeout(1)  # Simula o tempo de execução de uma instrução

                # Exibe informações sobre a execução do processo
                print('%s \nProcesso em EXECUÇÃO -> %d - RAM: %d, Instruções restantes: %d, RAM disponível: %d' % (name, env.now, ram, instrucoes, memoria.level))

        if instrucoes > 0:
            yield env.timeout(1)  # Simula o tempo de troca de contexto

    yield memoria.put(ram)  # Devolve a quantidade de RAM utilizada pelo processo
    # Exibe informações sobre o término do processo
    print('%s \nProcesso TERMINADO -> %d - RAM devolvida: %d, RAM disponível: %d' % (name, env.now, ram, memoria.level))

    global tempo_total  # Variável global para armazenar o tempo total de execução dos processos
    tempo_total += env.now - tempo_chegada  # Calcula o tempo de execução do processo
    print('Tempo de retorno: %d\n' % (env.now - tempo_chegada))  # Exibe o tempo total de execução

# Inicialização do ambiente de simulação
random.seed(50)  # Define a semente para geração de números aleatórios
env = simpy.Environment()  # Cria o ambiente de simulação

# Criação de recursos para simular a memória RAM e a CPU
memoria_ram = simpy.Container(env, init=30, capacity=30)  # Memória RAM com capacidade inicial e máxima de 30 unidades
cpu = simpy.Resource(env, capacity=1)  # CPU com capacidade de 1 unidade

quantidade_processos = 8  # Número de processos a serem simulados
tempo_total = 0  # Inicializa o tempo total de execução dos processos
quantum = 2  # Definição do quantum de tempo

# Loop para criar os processos e adicioná-los ao ambiente de simulação
for i in range(quantidade_processos):
    chegada = 0  # Tempo de chegada do processo
    instrucoes = random.randint(1, 10)  # Número aleatório de instruções do processo
    uso_ram = random.randint(1, 10)  # Uso aleatório de RAM pelo processo
    env.process(processo('Processo %d' % i, env, memoria_ram, cpu, chegada, instrucoes, uso_ram, quantum))  # Criação do processo

env.run()  # Inicia a simulação